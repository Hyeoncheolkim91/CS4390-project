Final Review

Privileged Instruction
What are they, and who gets to execute them?
Instructions that are restricted to the OS.  Such as directly access I/O devices, manipulate memory state management, manipulate mode bits.  Can only be executed in kernel mode.

Why do they need to be privileged?
So that a user cannot have direct access ? security + reliability.

Why do they need to be priveledged?
To restrict user access ? user has to switch to kernel mode via system call.

Events
Exceptions ? what generates them? 
Exception are software generated interrupts.  Traps are expected exceptions ? like a system call, faults are unexpected ? like divide by 0.

Interrupts ? what generates them?
Interrupts are generated by hardware.  Like the clock can generate an interrupt, or an I/O device finishing generates an interrupt.

OS Structure
What are the major components of an OS?
Process, Memory, I/O, Secondary storage, File Systems, GUI, Networking.

How are they organized?
Monolithic ? User programs sat on top of the OS, which is everything other than the hardware.  Hardware sits below the OS.  Advantages:  Procedure Calls cost is low. Disadvantages: hard to understand, or modify.  Unreliable.

Layering  - OS is implemented as a set of layers.  Each layer is a virtual machine to layer above.
Layer 0 ? Hardware Layer 1 ? Kernel Layer 2- Page Manager Layer 3 ? Console Manager Layer 4 ? Device Manager Layer 5 ? Job Manager  Advantages ? easy to debug.  Disadvantages -  poor performance because of overhead associated with layers.  Imposes hierarchical structure to OS, when Os is not really hierarchical.

Microkernels ? Removes non-essential components from the kernel and implements them as system and user level programs.  Advantage: more reliable, ease of extention.  Disadvantage:  poor performance.  

Processes
What is a process?
Process is a job ? a program in execution

What does it virtualize?

Difference between Process, Program, Thread.
A process is a program in execution. The program has been brought into memory.  Multiple execution states (stack and stack pointer, PC, set of general purpose registers) are achieved by a thread. 

What is contained in a process? What does a PCB contain?
A process contains a data structure called a PCB (Process Control Block).  This is where the OS keeps all of the processes hardware execution state. A PCB contains an address space, code of running program, data of running program, execution stack and stack pointer, program counter, general purpose registers, and more.  When a process is running, its hardware state is inside the CPU.  When it stops running, register values are saved inside PCB, and PCB is transferred to another queue (context-switch).  When a process is created, OS allocates and initializes PCB, and puts the PCB on the right queue.  

State Queues ? what states and transitions are possible?  When do they happen?
Has 3 states ? ready, running, and waiting.  Ready ? could run but another process has CPU.  Waiting ? waiting for some event (I/O). Running ? executing on the CPU.  Running -> waiting or ready.  Waiting -> ready.  Ready -> running. When CPU changes from one process to another it is a context switch.  State changes happen as the result of an interrupt or exception. 

How do you load a program into memory?
Create PCB, create page table, put AS image on disk in page-sized chunks.  Build page table (all valid false, all PTE correspond to proper places on disk, initially all instructions fault.

Process Manipulation
What does fork do? 
Creates and initializes new PCB, creates new address space, and initializes new address space with copy of contents of entire address space of the parent.  Places new PCB on ready queue.  When fork() is executed, the new process contains a copy of  the pages of the parent process under a rule of copy-on-write. The pages in the new address space are marked read-only. When the new process attempts to modify a page, a hardware interrupt occurs. The kernel makes a copy of that page, and changes the new address space to point to the copied page. Then the process continues to execute, modifying the page of which it now has a unique copy.

What does exec do?
Exec stops the current process, loads the program ‘prog’ into the address space, initializes hardware context, args for new program, and places PCB on the ready queue.  The prog overwrites the memory image of the program containing the exec() system call.

Wait()
Moves itself off of the ready queue until the termination of the child.  Wait returns the process ID of the terminated child so that it call tell which one of its children has terminated.  

How do shells work?
Continual loop…read in user command, fork, call exec, parent process waits…

Threads
What is a thread?
A sequential execution stream within a process.  Threads are bound to a single process.  All threads within a process use same address space.  Contains execution stack and stack pointer, as well as PC and general purpose registers.  When thread is created it is put on the ready queue.  Thread operations are all system calls (context-switch, yield).  

User level threads vs. Kernel Level threads
User level threads are managed by user level thread library.  Cheaper than kernel threads b/c creating a thread, switching between threads, and synchronizing threads done via procedure calls (no kernel involvement is necessary).  Creating a user level thread usually requires the creation of a user level thread.
All operations on kernel threads require a kernel call and parameter verification.

How does thread scheduling differ from process scheduling?
Scheduling a thread is cheaper.  When you have to context switch between threads, you change the hardware state from different TCB, and you wuoldn’t have any kind of procedure that would flush the TLB… however with a process, TLB could be flushed leading to increased overhead from page faults.

What operations do threads support?
Stuff in the user level thread package.




What happens on thread context switch?  What is saved in TCB?
On a thread context switch, saves context of currently running thread, put hardware state onto stack, restore context of next thread(get machine state from next thread), and return as new thread.  The TCB contains a stack, stack pointer, PC, and register values.


Synchronization
Why do we need it?
Sharing of resources / data structures, and coordinating execution (buffering problem between disk / network).

Race Conditions?  When do they occur?
Two threads try to access a shared resource at the same time.  Non-deterministic behavior.

What resources are shared?
Global variables and dynamic objects (stored in heap).  

What is mutual exclusion?
Used to synchronize access to shared resources.

Critical Section 
Code that uses mutual exclusion to synchronize its execution.

Requirements of Critical Sections
Mutual exclusion of critical sections ? at most one thread in critical section.  Progress ? a thread outside critical section cannot prevent anther thread from entering critical section.  No starvation ? thread S will eventually enter critical section

Mechanisms for Dealing with critical sections
Locks ? use atomic test and set
Semaphore ? binary and counting ? waiting queue and locks
Mutex ? waiting queue, lock
Monitor ? requires language support, easy to program with
Problems with disabling interrupts ? user can’t do it.  Insufficient on multiprocessor ? each processor has own interrupt mechanism.

Locks and Semaphores
What does it mean for acquire/release to be atomic?
Atomic instructions are hardware instruction that cannot be preempted / they are uninterruptible.

How can locks be implemented?
void acquire (int lock) {
while (atomic_test_and_set(lock) == 1)
problem here - preempted w/o setting lock to true.
lock = 1
}

void release (int lock) {
lock = 0;
}

int atomic_test_and_set (int lock) {
if (lock == 1) {
return 1;
} else{
return 0;
}

lock  can still get preempted while spinning, between calling atomic_test_and_set.  Limitation of locks is that they spin ? wasteful.  Also problems with preemption & inability to disable interrupts.

Sempahores ? either binary (muxex) or counting semaphore.
For counting semaphore, if lock > 0 ? available lock <= 0 unavailable

Wait (P), vs. Signal (V)
P ? 
Void P (Semaphore s) {
	if (s->lock == 1) {
	enqueue(current thread, s->wait_queue)
	thread t = dequeue(rdy_queue)
	context switch(current thread, t)
	} else {
	lock == 1
}

void V (semaphore s) {
	if (s->wait_queue isempty) {
	s->lock = 0;
	} else {
	thread t = dequeue(wait_queue)
	enqueue(t, rdy_queue)	
}

Look over in DETAIL ? reader/writers problem, producer / consumer

Semaphore - Threads are blocked at the level of program logic and placed on queue rather than busy waiting.  For real mutual exclusion busy waiting required, but very short critical sections.



P  ? critical section (interrupts disabled)



V ] ? critical section (interrupts disabled)

Look over monitor / condition variable stuff.

Process Scheduling
Long Term vs. Short Term
Short term ? selects processes in memory that are ready to execute and allocates CPU to that process.
Long term  - selects processes from disk and loads them into memory for execution.  

When does job scheduling happen?
When process changes state (ready -> running, wait-> ready, running -> wait, ready)
Result of an interrupt or exception
Job creation

Scheduling Goals?
Maximize CPU utilization, maximize job throughput, minimize response time
Batch scheduling - ?
Interactive scheduling - ?

What is starvation?  What causes it?
Starvation is when something is not given a chance to ever complete.  Starvation is caused by scheduling / preemption which gives priority over some things over others, so that for instance larger processes are given priority over shorter processes. 

FIFO ? first come first serve.  Average response time bad.  NO STARVATION.  May need to poor utilization of other resources.
SPT ? Shortest processing time first.  Have to know the future -> not really feasible.  
SRPT ? shortest remaining processing time first (preemptive).  Starvation.  Need to know future.
Priority ? highest priority jobs are run first (preemptive  / nonpreemptive).  Starvation -> solution, age processes over time.
RR ? round robin (time quantum)
MLFQ ? multi level feedback queue -  processes move between queue (they can each have their own scheduling algorithm).  Higher level queues have priority over lower level queues.    Awards interactive behavior, because processes dynamically change priority.  

Memory Management

What good is virtual memory?
Virtual memory allows programs to execute without requiring their entire address space to be resident in physical memory.  Programs can execute on machines with less RAM than it “needs”  Programs don’t need all of their data / code at once.    Also isolates processes from one another -> each process has its own isolated address space.  Two processes can run together even is a+b < total mem. A page # 1234 is different for process a and process b, because each have separate page tables <- loaded when program starts.

Paged Virtual Memory 
The full used address space exists on secondary storage.  OS uses main memory as page cache.  A page that is needed is transferred to a free page frame.  If there are no free page frames, a page must be evicted (and written to disk ? if dirty).  Managed by hardware and OS.

Mechanisms for implementing memory management
Physical vs. Virtual Addressing ? Makes it easier to manage memory of multiple processes.  Virtual addresses independent of location in physical memory.  Translated into physical addresses by hardware.  
Contiguous virtual addresses start at 0, but not in hardware.  

Fixed Partitions ? Physical memory equally sized, partitioning never changes.  Hardware requirement (base + limit registers).  Physical address = virtual address + base register.  Advantages ? simple.  Disadvantages ? internal fragmentation (memory in a partition not used by its own process ? but not available to other processes), also external fragmentation ? two small partitions lefts, but one big job (partition 1, 3, used and doesn’t fit in 2 or 4).  Partition size fixed at bootstrap.  Program loaded into partition that fits best.  When context switch load base and limit registers into partition.

Variable Partitions ? Physical memory broken up into variable sized partitions.  Physical address = virtual address + base register.  Advantages ? no internal fragmentation, but external fragmentation -  as load and unload jobs holes left throughout physical memory. 

Dealing with fragmentation  stops everyone’s execution & compacts memory (adjusts base and limit registers ? what causes virtual addresses to point to physical address.  

Paging ? program divided into pages of same size.  Page tables translate to physical addresses.  Sharing between processes by telling system want to share set of pages.  Processes view memory as contiguous address space but  physical mem. is non-contiguous.    But virtual pages are really scattered across physical memory frames.  Program cannot reference memory outside of VAS ? protection Advantage: no external fragmentation.  Easy to allocate physical memory (just allocated from free list of frames).  Entire program need not be memory resident (in memory). User sees memory as contiguous.  Disadvantages: But internal fragmentation ? extra space between stack and heap (virtual AS).  Extra space at end of page table (not multiple of 4K).  Mem. Reference overhead, 2 references per address lookup.  Solution: use TLB ? hardware cache.  

Translating Virtual Addresses ? virtual address has VPN & offset.  VPN is index into page table which contains page frame number.  Physical address = page frame # + offset.  VPN -> PFN + offset = physical address. 

Segmentation ? partition address space into logical units (stack, heap, subroutines, etc.) VA is <segment #, offset>. Segment number -> segment table which holds base and limit registers, which point to physical memory.  Like variable sized partitions.   Sharing is easy ? two things reference same segment.  But external fragmentation.

Really uses segmentation and paging.  Segments manage logical units [segment #, page #, offset within page].  Segement # - place where page table for segment located, page # - offset in segment.  Each segment has it own page table this way there is a page table per segment rather than per user address space.  No contiguous allocation, no external fragmentation.  

Whats in a PTE? What are modify / reference / valid / protection bits?
Each process has its own page table.
Page table entries control mapping.
Valid ? says whether or not the PTE can be used (checked each time a virtual address is used)
Referenced ? says whether it has been accessed (set when page read / written)
Modified ? says whether it is dirty (set when write occurred)
Protection bits ? tell what is allowed (read, write execute)
[V | R | M  | PROT |  PFN]  1 bit, 1 bit, 1 bit, 2 bit, 20 bit ? page frame number + offset = physical address

How to reduce the overhead of page table? 
With TLB and multi-level page tables.

TLB solves the problem of the memory reference overhead of address translation
TLB ? absorbs page table lookups by caching must recent pages.  Can translate virtual page #s into PTEs in one address cycle.  They are implemented in hardware.  Cache tags are VPNs and values are PTE.  OS ensures that TLB and page tables are consistent (i.e if OS changes protection bits in a PTE, it needs to invalidate the PTE if it is in the TLB.  During context switch ? all entries in TLB are flushed (to that VA 100 for process A is different from VA for process B). When TLB misses, a new PTE is loaded and a cached one is evicted (LRU).  MMU calculates physical address with PTE+offset.  Small (16-48 entries ? b/c of locality).  Searched before hardware walks page tables.  Hit: address translation not require extra memory reference.  Miss: hardware walks PT to translate address, translation put in TLB, evict other translation (managed by LRU).

Multi-level page tables solves memory problem ? mem. required to hold page tables can be huge.  
Need one PTE per page in VAS.  Virtual Address Space? 
32 bit As with 4kb pages = 2^20 PTE.  4 bytes / PTE = 4PM per page table

Wire down (pinned in physical memory) systems page tables in physical memory.  Allow system segment containing user page tables to be paged.  References to non-resident portions of a user page table is a page fault in the system address space.  Master page number, secondary page number, offset.  Master PT -> secondary PT ? uses index of secondary page number -> PFN + offset = physical address. 

Page Fault
When page was evicted OS sets the PTE as invalid and stored the disk location of the page in the PTE or parallel data structure.  When process tries to access the page, the invalid PTE will cause an interrupt to be thrown.  Page fault handler finds on disk -> starts I/O (now in memory) -> fix page table so that PTE point to memory, modified and referenced off, valid on, then context switch back to process.  


Demand Paging
Pages are only brought into memory when they are referenced.  Basically waits for user to demonstrate that they need the page via page fault before bringing it in.  How page faults are handled.  Not uncommon to cluster pages ? brings in all when one is referenced.

Page Replacement
If free page frames, use it, if not evict one.  Determining which one to evict is page replacement.  
Goal ? reduce fault rate by selecting best victim.  There is no best practical algorithm ? depends on workload.  Worst algorithm ? no, but random is pretty bad.  

Beladys Algorithm ? optimal ? remove the page that won’t be used for the longest time in the future.  Impossible to predict the future. Useful to compare other algorithms to.  

FIFO ? when page in something put at tail of list, evict at head of list.  Performance bad b/c when something is brought in has nothing to do with when it will be referenced to again or retrieved. 

LRU ? least recently used.  Idea: past is good indicator of future.  On replacement evict the page that hasn’t been used for the longest period of time.  Works well, but requires lots of memory bandwidth ? updating data structures + searching through timestamps at each memory reference.

LRU clock ? arranged physical frames in a big circle.  (sweep through pages in circular order like a clock).  If ref bit off we have a victim (hasn’t been referenced in a long time).  If on, turn off, and go to next page.  

Local replacement ? pages agains’t itself ? its own pages.
Global ? victim chosen from among all page frames.  

Working set
Working set is the pages a process currently needs, and how many of them.  Working set size changes over time.  During periods of poor locality the working set size is larger.  

PFF ? Page fault frequency 
Attempts to equalize fault rate among all processes  and have tolerable “system wide” fault rate.  1) monitor fault rate of each process, if fault rate is above threshold, give it memory, if fault rate is below threshold take away memory.  Looking for “sweet spot.”  

Thrashing
When system spends most of its time servicing page fault rather than doing useful work.  Either from not enough memory, or lousy replacement algorithm or too many active processes. 

Memory Hierarchy
CPU registers, L1 cache, L2 cache, primary memory, secondary storage.  

Disk
Platter, cylinder, surface, sector, track

Seek ? moving disk arm to correct cylinder (seek times aren’t diminishing very quickly
Rotation ? waiting for the sector to rotate under head (rates increasing slowly)
Transfer ? transferring data from surface into disk controller (increasing very quickly)

Look at HW
FCFS ? first come first serve ? do nothing
SSTF ? shortest seek time first ? unfairly favors middle blocks ? minimize arm movement
SCAN ? elevator algorithm ? service in one direction until done then reverse
C-SCAN ? scan but only in one direction
Files and Directories
A file is a collection of data with some properties (types).  

What operations are supported?
Create, open, read, write, sync, seek, close, unlink.

What characteristics do they have?
Type.

What are file access methods?
The ways in which a FS can specify the way an application accesses the file.
Sequential access ? read bytes on at a time in order.
Direct Access ? random access given by block / byte # (kinda like FCFS for disk read in random order)
Indexed Access ? index to a particular field of each record in a file, apps find a file based on value in that record (like a database)
Record Access ? file is array of fixed ? or variable sized partitions

Directories
Directories are a way for users to organize their files, and a convenient file name space for both users and FS.  Directory is a file that contains special metadata, list of files, attributes (size, protection, location on disk), directory list unordered.  
Path Name Translation
Open “/one/two”  / is a directory ? open it search for one, Open one, search for file two and open it.  FS spends time walking down directory paths.  Name associated with number.  Number is file descriptor number ? by which file is known. “/” is string, so is “one”, which associated with file descriptor number.  File descriptor number is the inode, file name is logical name.  

Access Control Lists vs. Capabilities
For file protection to control who and how someone can access a file.  Files = objects, users = principals, read/write = actions.   
ACL = for each object, keep list of principals and principles allowed actions.  = column
Easier to manage.  Easy to grant a revoke ? but need t keep track of principals associated with each object ? which is hard to do. They grow very large when easily shared.  Can put people into group and give permissions for entire group.

Capabilities = for each principal, keep list of objects and principals allowed actions for each object.  = row
Easy to transfer, and make sharing easy. Difficult to manage.  

FS Layout
Disk divided into 5 parts [boot | superblock | i-node area | file contents area | swap area]  Boot ? boot the system by loading this block.  Superblock(fixed place) ? specifies boundaries of next 3 areas and contains head of freelists of inodes and file blocks.  I-node area ? descriptors for each file on the disk ? all i-nodes same size.  File contents area ? fixed size blocks   Swap area ? processes that have been swapped out of memory.  

How to allocate space to files to that disk space is utilized effectively and files can be accessed quickly.
Contiguous Allocation ? each file occupy a set of contiguous blocks on the disk .  ? Disadvantages: external fragmentation.  Hard to determine how much space is needed for a file.  (too little bad / too much bad).

Linked Allocation ? solves problems of contiguous allocation ? each file is a linked list of disk blocks.  Blocks may be scattered anywhere on the disk.  No external fragmentation.  Disadvantage:  find ith block requires traversing series of links.  Also space required for pointers.  Reliability ? what happens if one link is lost?

Indexed Allocation ? Brings all the pointers together in one block ? the index block.  Solves problem of traversing links.  Advantages:  supports direct access without external fragmentation.  Index block ? talked about in class ? direct, indirect pointers, etc.

What is an inode?
It is at the header of every file.  Contains:  user number, group number, protection bits, times, file code:  directory , user file, or special file.  Size, block list ? contents of file, link count ? number of directories referencing this inode.  Each file is known by a number = number of the inode.
Block list portion of inode points to blocks in file contents area.

To create a file ? system call creates i-node.  Sets size to zero and nulls out block list ? when starts writing, allocates to block list.

Double check the next two questions…
How are inodes different from directories?
In the tree file system, directories contain inode numbers and file names.  They are a table.  Inodes contain metadata for files.  

How are inodes and directories used to do path resolution and find files?
Given file name, search directory, get inode number, from block list get content of file.

File system consistency
Inodes and blocks are cached in memory.  “sync” forces memory-resident disk information to be written to sdisk.  Crash or power failure can leave inconsistent disk.  Icheck ? is each block on exactly one list? Required going through all blocks in each inodes block list and also entire block list.  Dcheck ? does the link count of each file equal number of directories that link to it?  Do the directories form a three?  

FS Buffer Cache
Part of system memory, shared by all processes.  
Caching reads vs. writes ? caching reads good for operations that perform a lot of I/O.  caching writes saves time with I/O ? but eventually will have to be written back to disk.  Thus most disk traffic is write traffic.  
Write-through ? place data on disk as soon as it is in the cache ? little is lost in case of disk crash
Write-back ? updates are delayed ? first written to cache and updates written at a later time.  Writes complete more quickly, and data can be overwritten before written back.  Reliability problems ? during crash
Write-behind ? modified data is added to a write-behind queue, queue updates periodically

Read ahead into the cache ? increasing effectiveness of cache?

FFS, LFS
What is FFS, how specifically does it improve over original unix FS?
Original UNIX FS had two major performance problems:  1) data blocks allocated randomly in aging file system ? originally contiguously, but as deletions occur, free spaces “randomly” placed.
2) inodes far from blocks
Both of these generate many long seeks!

Berkeley Fast File System
FFS fixes this by using cylinder groups.  Disk partitions into groups of cylinders, data blocks from a file are all placed in the same cylinder group, files in the same directory are placed in the same cylinder group, inode for file place in same cylinder group as files data.  Basically treated a single big disk as multiple small disks, however this introduced additional free space requirements (to allocate according o cylinder group the disk must have free space scattered across all cylinders).  UNIX FS had 512B blocks ? problems even more seeking, small max file size. FFS uses 4KB blocks, which allows for large files, but introduces internal fragmentation ? fix: introduce fragments: multiple small files in a single block.

Check logic.
How about LFS ? basic ideas, when does it yield and improvement, when does it not?
A log is written to disk that is a log of changes made to files.  Log includes modified data blocks and metadata blocks.  Buffer ? segment in memory ? when full write it to disk on efficient contiguous transfer (end of log).  Therefore, disk contains a single big long log of changes consisting of threaded segments.  Disk is used as a log ? only updated at end.  Greatly increases disk write throughput.  Over time segments in log become fragmented as we replace old blocks of files with new blocks.  Major problem with LFS is cleaning ? producing contiguous free space on disk.  No consistency checks are needed.  Good write performance.  However, it becomes less efficient as it nears maximum capacity, when the garbage has to run more.  Also for slow growing files ? performance penalty b/c data spread over many segments.  

Whenever a file or directory is changed, LFS writes to the head of this log:
1.	Any changed or new data blocks.
2.	Indirect blocks updated to point to (1).
3.	Inodes updated to point to (2).
4.	Inode map blocks updated to point at (3).
RAID
Problem: disk transfer rates are improving but much less fast than CPU performance.
By:  striping across multiple disks:  parallel I/O ? 100 disks have 1/100th of response time.  Great for performance but need to do something about reliability.  Reliability requires redundant data.  Redundancy add parity ? to each byte add a bit so that the total number of ones is even.  Any single missing bit can be reconstructed.  Raid 5 ? block interleaved distributed parity (distribute parity info) Raid 0 ? non-redundant disk array.  Raid 1- mirrored.  Raid 2, 3, 4 ? use parity disks or (ECC ? error correcting code).  

Networking
Broken up into 7 layers ? physical layer, data link layer (SLIP PPP), network layer (Internet protocol), transport layer (TCP UDP), session layer , presentation layer (HTTP, FTP, POP SMTP, Telnet) , application layer

Ethernet Protocol ? CSMA-CD ? carrier sense multiple access with collision detection.  Packetized ? fixed size.  Interface listens for its address, interrupts OS when a packet is received.


Ask about how physical address & IP address change when forwarding to other networks.
IP & Routing ? IP ? routes packets across multiple networks from source to destination 172.30.192.1 ? logical address.  Individual networks are connected by routers that have physical addresses .  From one network to another ? router looks at payload of packet, and noticed IP address is not me, then forwards to another network.  When leaves router, IP address and data are the same, but physical address of computer on network changes.  [physical address, IP address, payload].

TCP ? manages to fabricate reliable multi-packet messages out of unreliable single-packet frames.  Packets arriving out of order.  Needs to be able to insure if everything has arrived (requires knowing total # of packets), and be able to piece the puzzle together.  Using TCP/IP and lower layers can get message reliably from A to B and from B to C without knowing any of the underlying details.  [physical address, IP address, TCP stuff, payload]

RPC

What is the advantage over message passing?
Message passing you need to worry about message format, have to pack and unpack data from messages.  Servers have to decode message and dispatch to handler.  Messaged asynchronous ? what do you do waiting for one to come back? 
With RPC ? traditional procedure call syntax and semantics across network (server exports API), client calls servers procedure’s API.  Don’t have to do anything more complicated that calling procedure locally.  
Largely invisible to programmer.

Binding ? how client connects to the network.  Server identifies itself on name server, tells RPC runtime that it is ready to accept calls.  The client before issuing any calls imports the server (uses the name server to find the location of the server and establish a connection).  

Stub ? client calls a local procedure ? a stub routine ? that packs its arguments into a message and sends them across the network to a particular server process.  The client side stud then blocks.  The server unpacks the message, calls the procedure, packs the return results in a message ,and sends them back to the client stub, the client stub unblocks, receives the message unpacks the results of RPC, and returns to the caller.  This is marshalling.  
Other wording - Client stub marshals the parameters into a message, and server unmmarshals parameters and uses them to invoke server procedure.  On return, server stub marshals the return value.  The client stub unmarshals the return value and returns them to the client program.


The client program things its invoking the server but really its calling into the client side stub.  The server program thinks its called by the cleitn, but its really called by server-side stub.  Stubs send messages to each other via runtime to maek the RPC happen transparently.  Runtime system (TCP/IP).  

Transparency ? binding breaks transparency.  Failures also break transparency ? server crash.  
Thread Pools ? if two clients simultaneously invoke same server using RPC ? two separate threads run on server -> needs to dispatch threads into server-side stubs when messages arrive… limit to # of threads?

Distributed Systems
Loosely coupled ? each CPU runs an independent OS, some resources shared, no trust, long communication times.
Closely coupled ? runs single OS, shares all logical resources (files), shares all physical resources).  
Tightly coupled ? multiprocessor, single OS, single job queue, single AS, very low communications latency, shared memory.  

Issues ? security, reliability, performance, scalability, programming models, communication models. 

Grapevine ? user prepares message using mail client, mail client contacts grapevine.  Grapevineuser package contacts registration server to get list of message servers.  Contacts message server with authentication and source and destination IDs.  Message server receives message, calls registration server (for each recipient of the message ) to get list of message servers for recipient, and sends message body to one of the message server for that user.  Every user has multiple inboxes.  
To retrieve mail, user app contacts grapevine.  Grapevine user package contacts registration server to get message servers for that user “inbox site” .  contacts each of these message servers to get mail (with credentials)  

Buffer overflow ? how exactly does it work on x86?
